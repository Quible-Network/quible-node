# TypeScript SDK

Use the Quible TypeScript SDK to simplify interactions with the Quible Network. No configuration is required for requesting and signing certificates, however for creating and updating identities, you will need a hexadecimal 32-byte ECDSA private key.

## Installation

To install the Quible TypeScript SDK, use this command:

```
npm install @quible/sdk
```

## Creating identities

Identities are Quibleâ€™s core building block. A wallet can create new identities at any time. With an identity, you can store claims and request corresponding attestations from the network that prove that the claims have been associated with that identity. This attestation is also known as a certificate. Claims can be added to or removed from an identity at any time. Identities can be owned by one or more wallets. Claims are arbitrary-length byte vectors.

After an identity is created, it has a unique identifier which is used to request certificates and update the identity.

With an identity, you can also configure the `certificateLifespan` which controls how quickly a certificate will expire when generated by the network. This value is the number of seconds from the issuance date until the certificate becomes expired.

```ts
import {Wallet} from '@quible/sdk'

const privateKey = '...'

const wallet = Wallet.fromPrivateKey(privateKey)

const identity = await wallet.createIdentity({
  claims: [
    new UInt8Array([0xd, 0xe, 0xa, 0xd, 0xb, 0xe, 0xe, 0xf]),
    { hex: '0xdeadbeef' },
    { hex: '0x0000000000000000000000000000000000000000' }, // Example: 160-bit Ethereum wallet address
    'utf8 string'
  ],
  certificateLifespan: 86400
})

console.log('identity id: ', identity.id.toHex())
```

## Updating identities

Identities store claims as unordered sets. When updating an identity, you may provide a list of claims to-be-inserted, and/or a list of claims to-be-deleted.

```ts
import {Wallet, Identity} from '@quible/sdk'

const privateKey = '...'
const identityId = '...'

const wallet = Wallet.fromPrivateKey(privateKey)
const identity = Identity.fromId(identityId)

await identity.update({
  wallet,
  insert: ['new value'],
  delete: ['old value']
})
```

## Issuing certificates

To to issue a certificate for a set of claims, use the `getCertificate` method. This method sends a certificate signing request to the network, and if all claims are included in the identity at the time of the request, a new certificate is returned by the method.

```ts
import {Identity} from '@quible/sdk'

const identityId = '...'

const identity = Identity.fromId(identityId)

const claims = [
  'utf8 string',
  { hex: '0xdeadbeef' },
  new UInt8Array([0xd, 0xe, 0xa, 0xd, 0xb, 0xe, 0xe, 0xf]),
]

const certificates = await Promise.all(claims.map(async (claim) => {
  const certificate = await Identity.getCertificate({
    claims: [claim]
  })

  console.log([
    certificate.toBytes(),            // encoded certificate data as UInt8Array
    certificate.claims[0].toBytes(),  // first attested claim value as UInt8Array
    certificate.claims[0].toString(), // first attested claim value encoded as utf8 string
    certificate.identity.id.toHex(),  // identity id in hexadecimal format
    certificate.expiresAt,            // expiration date in seconds since unix epoch
    certificate.toJSON(),             // JSON-serializable representation of an certificate
    certificate.signature.toHex(),    // Secp256k1 32-byte ECDSA signature from the Quible network, in hexadecimal format
  ])

  return certificate
}))
```

## Verifying certificates

To verify an certificate, you can use these methods on an certificate object: `isValid` and `verify`.

```ts
import {Certificate} from '@quible/sdk'

const certificate = Certificate.fromJSON(JSON.parse('...'))

certificate.isValid() // returns a bool indicating valid/invalid
certificate.verify() // throws an error if invalid

// additionally, check validity, identity and value in one step:
certificate.verify({
  identity: { id: { hex: '0x...' } },
  value: { hex: '0x...' }
})
```
